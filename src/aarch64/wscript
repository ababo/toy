COMP_CXXS = {
    'gcc': 'aarch64-linux-gnu-g++',
    'clang': 'clang++'
}

CXX_FLAGS = []
CXX_COMP_FLAGS = {
    'gcc': [],
    'clang': ['-target', 'aarch64-none-linux-gnu']
}

LD = 'aarch64-linux-gnu-ld'
LD_FLAGS = []

AR = 'aarch64-linux-gnu-ar'
OBJCOPY = 'aarch64-linux-gnu-objcopy'

EMU = 'qemu-system-aarch64'
EMUFLAGS = ['-machine', 'virt', '-cpu', 'cortex-a57', '-machine', 'type=virt',
            '-nographic']


def configure(cnf):
    cnf.env.CXX = COMP_CXXS[cnf.env.comp]
    cnf.env.append_value('CXXFLAGS', CXX_FLAGS)
    cnf.env.append_value('CXXFLAGS', CXX_COMP_FLAGS[cnf.env.comp])

    cnf.env.LD = LD
    cnf.env.append_value('LDFLAGS', LD_FLAGS)

    cnf.env.AR = AR # just to avoid searching for native ar
    cnf.env.EMUFLAGS = EMUFLAGS

    cnf.find_program(OBJCOPY, var='OBJCOPY')
    cnf.find_program(EMU, var='EMU', mandatory=False)


def build(bld):
    objs = bld.objects(source=bld.path.ant_glob('*.cc'))
    objs.post()
    objs = [t.outputs[0] for t in objs.tasks] + bld.src_objs

    kern = bld(rule='${LD} ${LDFLAGS} ${SRC} -o ${TGT}',
               source=objs, target='kernel.elf')
    kern.post(); # depends_on doesn't work here
    kern.tasks[0].dep_nodes = [bld.path.find_resource('link.lds')]

    bld(rule='${OBJCOPY} -O binary ${SRC} ${TGT}',
        source='kernel.elf', target='kernel.bin')


def run(run):
    def call_emu(task):
        from subprocess import call
        call([run.env.EMU] + run.env.EMUFLAGS +
             ['-kernel', task.inputs[0].abspath()])

    build(run)
    run(rule=call_emu, source="kernel.bin", always=True)
