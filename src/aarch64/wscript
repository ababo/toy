COMP_CXXS = {
    'gcc': 'aarch64-linux-gnu-g++',
    'clang': 'clang++'
}

CXX_FLAGS = []
CXX_COMP_FLAGS = {
    'gcc': [],
    'clang': ['-target', 'aarch64-none-linux-gnu']
}

AS_FLAGS = ['-Qunused-arguments']

LD = 'aarch64-linux-gnu-ld'
LD_FLAGS = []

AR = 'aarch64-linux-gnu-ar'
OBJCOPY = 'aarch64-linux-gnu-objcopy'

EMU = 'qemu-system-aarch64'
EMUFLAGS = ['-machine', 'virt', '-cpu', 'cortex-a57', '-machine', 'type=virt',
            '-nographic']


def configure(cnf):
    cnf.env.CXX = COMP_CXXS[cnf.env.comp]
    cnf.env.append_value('CXXFLAGS', CXX_FLAGS)
    cnf.env.append_value('CXXFLAGS', CXX_COMP_FLAGS[cnf.env.comp])

    cnf.env.AS = cnf.env.CXX # for C-preprocessing
    cnf.env.ASFLAGS = cnf.env.CXXFLAGS
    cnf.env.append_value('ASFLAGS', AS_FLAGS)

    cnf.env.LD = LD
    cnf.env.append_value('LDFLAGS', LD_FLAGS)

    cnf.env.AR = AR # just to avoid searching for native ar
    cnf.env.EMUFLAGS = EMUFLAGS

    cnf.find_program(OBJCOPY, var='OBJCOPY')
    cnf.find_program(EMU, var='EMU', mandatory=False)


def build(bld):
    s_objs = bld.objects(source=bld.path.ant_glob('**/*.S'))
    cc_objs = bld.objects(source=bld.path.ant_glob('**/*.cc'))
    s_objs.post(); cc_objs.post()
    objs = [t.outputs[0] for t in s_objs.tasks] + \
           [t.outputs[0] for t in cc_objs.tasks]

    kern = bld(rule='${LD} ${LDFLAGS} ${SRC} -o ${TGT}',
               source=objs, target='kernel.elf')
    kern.post(); # depends_on doesn't work here
    kern.tasks[0].dep_nodes = [bld.path.find_resource('link.lds')]

    bld(rule='${OBJCOPY} -O binary ${SRC} ${TGT}',
        source='kernel.elf', target='kernel.bin')


def run(run):
    def call_emu(task):
        from subprocess import call
        call([run.env.EMU] + run.env.EMUFLAGS +
             ['-kernel', task.inputs[0].abspath()])

    build(run)
    run(rule=call_emu, source="kernel.bin", always=True)
